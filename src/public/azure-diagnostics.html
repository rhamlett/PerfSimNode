<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Azure Diagnostics Guide - PerfSimNode</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    .diag-container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 2rem;
    }
    .diag-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    .diag-header h1 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }
    .diag-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }
    .diag-nav {
      background: var(--card-background);
      border-radius: 8px;
      padding: 1rem 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .diag-nav ul {
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    .diag-nav a {
      display: inline-block;
      padding: 0.5rem 1rem;
      background: var(--background-color);
      border-radius: 4px;
      text-decoration: none;
      color: var(--text-color);
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .diag-nav a:hover {
      background: var(--primary-color);
      color: white;
    }
    .card {
      background: var(--card-background);
      border-radius: 8px;
      padding: 1.5rem 2rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .card h2 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }
    .card h3 {
      color: var(--text-color);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
    }
    .card h4 {
      color: var(--text-secondary);
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }
    .metric-explanation {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    .metric-box {
      border-left: 4px solid var(--primary-color);
      background: var(--background-color);
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }
    .metric-box.cpu { border-color: #ff8c00; }
    .metric-box.memory { border-color: #0078d4; }
    .metric-box.eventloop { border-color: #8764b8; }
    .metric-box.latency { border-color: #107c10; }
    .metric-box h4 {
      margin: 0 0 0.5rem 0;
      color: var(--text-color);
    }
    .metric-box p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    .scenario-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin: 1rem 0;
    }
    .scenario-card {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }
    .scenario-card .header {
      padding: 1rem;
      font-weight: 600;
      color: white;
    }
    .scenario-card .header.cpu { background: linear-gradient(135deg, #d83b01, #ff8c00); }
    .scenario-card .header.memory { background: linear-gradient(135deg, #0078d4, #00bcf2); }
    .scenario-card .header.eventloop { background: linear-gradient(135deg, #5c2d91, #8764b8); }
    .scenario-card .header.slow { background: linear-gradient(135deg, #ff8c00, #ffb900); }
    .scenario-card .header.crash { background: linear-gradient(135deg, #a4262c, #d83b01); }
    .scenario-card .body {
      padding: 1rem;
    }
    .scenario-card .body h4 {
      margin: 0.75rem 0 0.25rem;
      font-size: 0.9rem;
    }
    .scenario-card .body ul {
      margin: 0;
      padding-left: 1.25rem;
      font-size: 0.85rem;
    }
    .scenario-card .body li {
      margin-bottom: 0.25rem;
    }
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    .tool-card {
      background: var(--background-color);
      border-radius: 8px;
      padding: 1rem;
    }
    .tool-card h4 {
      margin: 0 0 0.5rem;
      color: var(--primary-color);
    }
    .tool-card p {
      margin: 0 0 0.5rem;
      font-size: 0.85rem;
    }
    .tool-card code {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-size: 0.8rem;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .comparison-table th, .comparison-table td {
      border: 1px solid var(--border-color);
      padding: 0.75rem;
      text-align: left;
    }
    .comparison-table th {
      background: var(--background-color);
      font-weight: 600;
    }
    .comparison-table tr:nth-child(even) {
      background: rgba(0,0,0,0.02);
    }
    .alert-box {
      padding: 1rem 1.25rem;
      border-radius: 6px;
      margin: 1rem 0;
    }
    .alert-box.info {
      background: #e6f3ff;
      border-left: 4px solid var(--primary-color);
    }
    .alert-box.warning {
      background: #fff4ce;
      border-left: 4px solid var(--warning-color);
    }
    .alert-box.success {
      background: #dff6dd;
      border-left: 4px solid var(--success-color);
    }
    .alert-box strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 1rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      margin: 1rem 0;
    }
    code {
      background: var(--background-color);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
    }
    pre code {
      background: none;
      padding: 0;
    }
    .flowchart {
      background: var(--background-color);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      text-align: center;
    }
    .flowchart .step {
      display: inline-block;
      padding: 0.75rem 1rem;
      background: var(--card-background);
      border: 2px solid var(--primary-color);
      border-radius: 6px;
      margin: 0.25rem;
    }
    .flowchart .arrow {
      display: inline-block;
      color: var(--primary-color);
      font-weight: bold;
      margin: 0 0.5rem;
    }
  </style>
</head>
<body>
  <header>
    <button id="hamburger-btn" class="hamburger-btn attention" aria-label="Open navigation menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <h1>üî• Performance Problem Simulator - Node 24 on Linux</h1>
    <span id="sku-badge" class="sku-badge">SKU: Local</span>
    <nav>
      <a href="/" class="btn-panel-toggle">üéÆ Dashboard</a>
    </nav>
  </header>

  <!-- Sidebar Drawer Navigation -->
  <div id="sidebar-overlay" class="sidebar-overlay"></div>
  <aside id="sidebar-drawer" class="sidebar-drawer">
    <div class="sidebar-header">
      <h2>üî• PerfSimNode</h2>
      <button id="sidebar-close" class="sidebar-close" aria-label="Close navigation">&times;</button>
    </div>
    <nav class="sidebar-nav">
      <div class="sidebar-section-label">Application</div>
      <a href="/" class="sidebar-nav-item">
        <span class="nav-icon">üéÆ</span>
        <span class="nav-label">Dashboard<span class="nav-desc">Live metrics & controls</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">Documentation</div>
      <a href="/docs.html" class="sidebar-nav-item">
        <span class="nav-icon">üìö</span>
        <span class="nav-label">Documentation<span class="nav-desc">API reference & guides</span></span>
      </a>
      <a href="/azure-diagnostics.html" class="sidebar-nav-item active">
        <span class="nav-icon">‚òÅÔ∏è</span>
        <span class="nav-label">Azure Diagnostics<span class="nav-desc">Diagnose issues in App Service</span></span>
      </a>
      <a href="/azure-deployment.html" class="sidebar-nav-item">
        <span class="nav-icon">üöÄ</span>
        <span class="nav-label">Deploy to Azure<span class="nav-desc">GitHub Actions + OIDC setup</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">External</div>
      <a href="https://github.com/rhamlett/PerfSimNode" target="_blank" class="sidebar-nav-item">
        <span class="nav-icon">üêô</span>
        <span class="nav-label">GitHub Repository<span class="nav-desc">Source code & issues</span></span>
      </a>
    </nav>
    <div class="sidebar-footer">
      PerfSimNode v1.0 ‚Ä¢ Node.js 24 LTS
    </div>
  </aside>

  <main class="diag-container">
    <div class="diag-header">
      <h1>‚òÅÔ∏è Azure Diagnostics Guide</h1>
      <p>How to diagnose Node.js performance issues using Azure tools and understand what the metrics mean</p>
    </div>

    <nav class="diag-nav">
      <ul>
        <li><a href="#understanding-metrics">Understanding Metrics</a></li>
        <li><a href="#diagnostic-scenarios">Diagnostic Scenarios</a></li>
        <li><a href="#azure-tools">Azure Tools</a></li>
        <li><a href="#diagnostic-workflow">Diagnostic Workflow</a></li>
        <li><a href="#kudu-console">Kudu Console</a></li>
        <li><a href="#v8-profiling">V8 Profiling</a></li>
        <li><a href="#app-insights">Application Insights</a></li>
      </ul>
    </nav>

    <!-- Understanding Metrics -->
    <section id="understanding-metrics" class="card">
      <h2>üìà Understanding the Dashboard Metrics</h2>
      <p>The PerfSimNode dashboard displays real-time metrics that help identify performance issues. Here's what each metric means:</p>

      <div class="metric-explanation">
        <div class="metric-box cpu">
          <h4>‚ö° CPU Usage (%)</h4>
          <p><strong>What it measures:</strong> Percentage of CPU time consumed by the Node.js process.</p>
          <p><strong>Why it matters:</strong> High CPU indicates compute-bound operations. In Node.js, this typically means synchronous code is running (crypto, JSON parsing large objects, complex calculations).</p>
          <p><strong>Normal range:</strong> 0-30% at idle, spikes during requests are normal.</p>
          <p><strong>Warning signs:</strong> Sustained >70% indicates a problem.</p>
        </div>

        <div class="metric-box memory">
          <h4>üìä Memory Working Set (MB)</h4>
          <p><strong>What it measures:</strong> Total memory the Node.js process has allocated and is actively using.</p>
          <p><strong>Why it matters:</strong> Memory that grows without releasing indicates leaks. Node.js uses V8's garbage collector, but references held too long prevent cleanup.</p>
          <p><strong>Normal range:</strong> Depends on app, but should stabilize after warmup.</p>
          <p><strong>Warning signs:</strong> Continuous growth over time (sawtooth pattern is OK).</p>
        </div>

        <div class="metric-box eventloop">
          <h4>üßµ Event Loop Lag (ms)</h4>
          <p><strong>What it measures:</strong> Time between when a callback is scheduled and when it actually executes.</p>
          <p><strong>Why it matters:</strong> <em>This is the key metric for sync-over-async problems!</em> When synchronous code blocks the event loop, ALL pending callbacks must wait‚Äîincluding incoming HTTP requests.</p>
          <p><strong>Normal range:</strong> &lt;10ms</p>
          <p><strong>Warning signs:</strong> >100ms causes noticeable delays; >1000ms means severe blocking.</p>
        </div>

        <div class="metric-box latency">
          <h4>‚è±Ô∏è Request Latency (ms)</h4>
          <p><strong>What it measures:</strong> Time from request received to response sent, including time waiting in the event loop queue.</p>
          <p><strong>Why it matters:</strong> Direct measure of user experience. High latency with low CPU often indicates blocking or external dependency issues.</p>
          <p><strong>Normal range:</strong> &lt;150ms for simple requests</p>
          <p><strong>Warning signs:</strong> >1s degraded; >30s critical.</p>
        </div>
      </div>

      <div class="alert-box info">
        <strong>üí° Key Insight: Event Loop Lag</strong>
        Node.js uses a <em>single-threaded event loop</em>. When you see high Event Loop Lag, it means the main thread is blocked and ALL pending callbacks must wait‚Äîthis is why a single blocking operation can affect ALL requests simultaneously.
      </div>
    </section>

    <!-- Diagnostic Scenarios -->
    <section id="diagnostic-scenarios" class="card">
      <h2>üîç Diagnostic Scenarios</h2>
      <p>Here's how to diagnose each type of performance problem this simulator creates:</p>

      <div class="scenario-grid">
        <div class="scenario-card">
          <div class="header cpu">üî• High CPU Usage</div>
          <div class="body">
            <p><strong>Symptom:</strong> CPU metric pinned high, requests may still complete normally (event loop not blocked).</p>
            <h4>What's Happening</h4>
            <ul>
              <li>Simulation spawns child processes via <code>fork()</code></li>
              <li>Each child runs CPU-intensive crypto (PBKDF2)</li>
              <li>Work is isolated from main event loop - server stays responsive</li>
              <li>Multiple <code>node</code> processes visible in <code>top</code></li>
            </ul>
            <h4>Key Insight</h4>
            <p><em>CPU stress ‚â† Event loop blocking!</em> High CPU in child processes doesn't block the server. Watch the Event Loop Lag - it stays low even with high CPU.</p>
            <h4>Azure Diagnostic Tools</h4>
            <ul>
              <li>App Service Diagnostics ‚Üí <strong>CPU Drill Down</strong></li>
              <li>Application Insights ‚Üí <strong>Performance</strong></li>
              <li>Kudu SSH ‚Üí <code>top</code>, <code>ps aux | grep node</code></li>
              <li><a href="#v8-profiling">V8 Profiling</a> ‚Üí <code>--prof</code> to identify hot functions</li>
            </ul>
            <h4>What to Look For</h4>
            <ul>
              <li>Which process(es) consuming CPU</li>
              <li>Parent/child process relationship</li>
              <li>Event loop lag should remain LOW</li>
              <li>V8 profile output showing high-tick functions</li>
            </ul>
          </div>
        </div>

        <div class="scenario-card">
          <div class="header memory">üìä Memory Pressure</div>
          <div class="body">
            <p><strong>Symptom:</strong> Memory grows, stays high, may eventually crash with OOM.</p>
            <h4>What's Happening</h4>
            <ul>
              <li>Simulation allocates Buffers and holds references</li>
              <li>V8 garbage collector can't free held memory</li>
              <li>Simulates memory leaks from caching gone wrong</li>
            </ul>
            <h4>Azure Diagnostic Tools</h4>
            <ul>
              <li>App Service Diagnostics ‚Üí <strong>Memory Analysis</strong></li>
              <li>Application Insights ‚Üí <strong>Metrics</strong></li>
              <li>Kudu ‚Üí <strong>Process Explorer</strong></li>
              <li><a href="#v8-profiling">V8 Profiling</a> ‚Üí Heap snapshots via Chrome DevTools</li>
            </ul>
            <h4>What to Look For</h4>
            <ul>
              <li>Heap snapshots to find retained objects (use Retainers view)</li>
              <li>Compare snapshots over time to identify growing allocations</li>
              <li>Memory growth pattern (leak vs. normal usage)</li>
              <li>Correlation with specific operations</li>
            </ul>
          </div>
        </div>

        <div class="scenario-card">
          <div class="header eventloop">üßµ Event Loop Blocking</div>
          <div class="body">
            <p><strong>Symptom:</strong> Event Loop Lag spikes, ALL requests queue, dashboard freezes.</p>
            <h4>What's Happening</h4>
            <ul>
              <li>Synchronous crypto runs IN the main thread</li>
              <li>All pending callbacks must wait</li>
              <li>Request latency = blocking duration + normal processing</li>
              <li><strong>Key difference from CPU stress:</strong> Server is unresponsive!</li>
            </ul>
            <h4>How to Identify</h4>
            <p><em>Check Event Loop Lag!</em> If it equals the slowdown duration, the event loop is blocked. CPU stress shows high CPU but LOW event loop lag.</p>
            <h4>Azure Diagnostic Tools</h4>
            <ul>
              <li>Application Insights ‚Üí <strong>Performance</strong></li>
              <li>App Service Diagnostics ‚Üí <strong>Web App Slow</strong></li>
              <li>Azure Monitor ‚Üí <strong>Metrics</strong> for request latency spikes</li>
              <li><a href="#v8-profiling">V8 Profiling</a> ‚Üí CPU profile during block shows blocking code</li>
            </ul>
            <h4>What to Look For</h4>
            <ul>
              <li>Event loop lag = blocking duration</li>
              <li>ALL requests affected simultaneously</li>
              <li>CPU may be high OR low (depends on blocking work)</li>
              <li>V8 profile identifies the synchronous function (e.g., <code>pbkdf2Sync</code>)</li>
            </ul>
          </div>
        </div>

        <div class="scenario-card">
          <div class="header slow">üê¢ Slow Requests</div>
          <div class="body">
            <p><strong>Symptom:</strong> Specific endpoint takes long time, but other endpoints are NORMAL.</p>
            <h4>What's Happening</h4>
            <ul>
              <li>Request handler uses <code>setTimeout()</code> for delay</li>
              <li>Non-blocking: event loop continues processing</li>
              <li>Simulates slow database, external API calls</li>
              <li><strong>Key difference from Event Loop Blocking:</strong> Only slow endpoint affected!</li>
            </ul>
            <h4>How to Identify</h4>
            <p><em>Check if OTHER requests are affected.</em> Slow requests: only slow endpoint is slow. Event loop blocking: EVERYTHING is slow.</p>
            <h4>Azure Diagnostic Tools</h4>
            <ul>
              <li>Application Insights ‚Üí <strong>End-to-end transaction</strong></li>
              <li>Application Insights ‚Üí <strong>Dependency tracking</strong></li>
              <li>Log Analytics ‚Üí Request duration by endpoint</li>
            </ul>
            <h4>What to Look For</h4>
            <ul>
              <li>Which specific endpoint is slow</li>
              <li>Dependency timing breakdown</li>
              <li>Event loop lag stays LOW</li>
            </ul>
          </div>
        </div>

        <div class="scenario-card">
          <div class="header crash">üí• Application Crash</div>
          <div class="body">
            <p><strong>Symptom:</strong> App becomes unresponsive, restarts, or returns 502/503 errors.</p>
            <h4>What's Happening</h4>
            <ul>
              <li>Unhandled exception crashes process</li>
              <li>OOM killer terminates process</li>
              <li>App Service may auto-restart</li>
            </ul>
            <h4>Azure Diagnostic Tools</h4>
            <ul>
              <li>App Service Diagnostics ‚Üí <strong>Web App Restarted</strong></li>
              <li>Application Insights ‚Üí <strong>Failures</strong></li>
              <li>Kudu ‚Üí <strong>LogFiles</strong></li>
              <li><a href="#v8-profiling">V8 Profiling</a> ‚Üí Heap snapshot before crash to identify cause</li>
            </ul>
            <h4>What to Look For</h4>
            <ul>
              <li>Crash dump analysis</li>
              <li>Exception stack trace in logs</li>
              <li>Memory usage before crash (heap snapshot comparison)</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- Azure Tools -->
    <section id="azure-tools" class="card">
      <h2>üõ†Ô∏è Azure Diagnostic Tools</h2>
      <p>Key Azure tools for diagnosing Node.js performance issues:</p>

      <div class="tool-grid">
        <div class="tool-card">
          <h4>App Service Diagnostics</h4>
          <p>Built-in diagnostic reports in Azure Portal. Access via "Diagnose and solve problems".</p>
          <p><strong>Best for:</strong> Quick health overview, CPU/memory analysis, crash investigation.</p>
        </div>
        <div class="tool-card">
          <h4>Application Insights</h4>
          <p>Full APM solution with request tracing, dependency tracking, and custom metrics.</p>
          <p><strong>Best for:</strong> End-to-end tracing, performance trends, failure analysis.</p>
        </div>
        <div class="tool-card">
          <h4>Kudu (SCM)</h4>
          <p>Developer console at <code>yourapp.scm.azurewebsites.net</code></p>
          <p><strong>Best for:</strong> Real-time debugging, log access, process management.</p>
        </div>
        <div class="tool-card">
          <h4>Log Analytics</h4>
          <p>Query-based log analysis with KQL.</p>
          <p><strong>Best for:</strong> Historical analysis, custom queries, alerting.</p>
        </div>
        <div class="tool-card">
          <h4>Azure Monitor Metrics</h4>
          <p>Platform metrics for CPU, memory, requests, etc.</p>
          <p><strong>Best for:</strong> Real-time monitoring, dashboards, alerts.</p>
        </div>
        <div class="tool-card">
          <h4>Crash Dump Analysis</h4>
          <p>Automatic or manual dump collection for crash investigation.</p>
          <p><strong>Best for:</strong> Post-mortem crash analysis, memory leak investigation.</p>
        </div>
      </div>
    </section>

    <!-- Diagnostic Workflow -->
    <section id="diagnostic-workflow" class="card">
      <h2>üîÑ Diagnostic Workflow</h2>
      <p>Follow this workflow when investigating a Node.js performance issue:</p>

      <div class="flowchart">
        <span class="step">Customer Report</span>
        <span class="arrow">‚Üí</span>
        <span class="step">Check Metrics</span>
        <span class="arrow">‚Üí</span>
        <span class="step">Identify Pattern</span>
        <span class="arrow">‚Üí</span>
        <span class="step">Deep Dive</span>
        <span class="arrow">‚Üí</span>
        <span class="step">Root Cause</span>
      </div>

      <h3>Step 1: Initial Assessment</h3>
      <ol>
        <li>Check App Service Overview for health status</li>
        <li>Look at CPU, Memory, Request metrics in Azure Monitor</li>
        <li>Note the timeframe of the issue</li>
      </ol>

      <h3>Step 2: Identify the Pattern</h3>
      <table class="comparison-table">
        <tr>
          <th>If You See...</th>
          <th>Likely Issue</th>
          <th>Next Step</th>
        </tr>
        <tr>
          <td>High CPU, normal response times</td>
          <td>CPU-bound processing (expected or bug)</td>
          <td>CPU profiling via Kudu</td>
        </tr>
        <tr>
          <td>High CPU, slow responses</td>
          <td>CPU starvation affecting requests</td>
          <td>Identify hot code path</td>
        </tr>
        <tr>
          <td>Normal CPU, slow ALL responses</td>
          <td>Event loop blocking (sync-over-async)</td>
          <td>Check event loop metrics, code review</td>
        </tr>
        <tr>
          <td>Normal CPU, slow SOME responses</td>
          <td>External dependency latency</td>
          <td>Application Insights dependency view</td>
        </tr>
        <tr>
          <td>Memory growing over time</td>
          <td>Memory leak</td>
          <td>Heap snapshot analysis</td>
        </tr>
        <tr>
          <td>Sudden restarts, 502 errors</td>
          <td>Crash (exception or OOM)</td>
          <td>Crash dump, error logs</td>
        </tr>
      </table>

      <h3>Step 3: Deep Dive Tools by Issue</h3>
      <div class="alert-box success">
        <strong>üî• High CPU</strong>
        <ol style="margin: 0.5rem 0 0; padding-left: 1.25rem;">
          <li>Kudu Process Explorer ‚Üí Identify process</li>
          <li>App Service Diagnostics ‚Üí CPU Drill Down</li>
          <li>Profile with <code>node --prof</code> or <code>--inspect</code></li>
        </ol>
      </div>
      <div class="alert-box success">
        <strong>üßµ Event Loop Blocking</strong>
        <ol style="margin: 0.5rem 0 0; padding-left: 1.25rem;">
          <li>Check Application Insights for correlated slow requests</li>
          <li>Look for sync operations in code (fs.readFileSync, etc.)</li>
          <li>Add monitoring with <code>perf_hooks.monitorEventLoopDelay()</code></li>
        </ol>
      </div>
      <div class="alert-box success">
        <strong>üìä Memory Leak</strong>
        <ol style="margin: 0.5rem 0 0; padding-left: 1.25rem;">
          <li>Take heap snapshot via Kudu or remote debugging</li>
          <li>Compare snapshots over time</li>
          <li>Look for growing object counts</li>
        </ol>
      </div>
    </section>

    <!-- Kudu Console -->
    <section id="kudu-console" class="card">
      <h2>üñ•Ô∏è Kudu Console Commands</h2>
      <p>Useful commands when connected to Kudu (SCM) console:</p>

      <h3>Process Information</h3>
      <pre><code># List Node.js processes
ps aux | grep node

# Show memory usage
free -m

# CPU and memory in real-time
top -p $(pgrep -f node)</code></pre>

      <h3>Profiling</h3>
      <pre><code># Generate CPU profile (run this, reproduce issue, stop with Ctrl+C)
# Profile saved as isolate-*.log
node --prof /home/site/wwwroot/index.js

# Process the profile
node --prof-process isolate-*.log > profile.txt</code></pre>

      <h3>Heap Snapshot</h3>
      <pre><code># Find Node.js PID
pgrep -f node

# Send signal to generate heap snapshot
kill -USR2 &lt;pid&gt;

# Or connect with Chrome DevTools
# 1. In Kudu, run: node --inspect=0.0.0.0:9229 /home/site/wwwroot/index.js
# 2. Set up port forwarding
# 3. Connect Chrome to chrome://inspect</code></pre>

      <h3>Log Analysis</h3>
      <pre><code># View recent application logs
tail -100 /home/LogFiles/Application/*.log

# Search for errors
grep -i "error\|exception" /home/LogFiles/Application/*.log

# Watch logs in real-time
tail -f /home/LogFiles/Application/*.log</code></pre>
    </section>

    <!-- V8 Profiling -->
    <section id="v8-profiling" class="card">
      <h2>üî¨ V8 Profiling</h2>
      <p>V8 is the JavaScript engine that powers Node.js. It includes built-in profiling tools that help identify performance bottlenecks, memory leaks, and CPU-intensive code paths.</p>

      <h3>What is V8 Profiling?</h3>
      <p>V8 profiling captures detailed information about your application's runtime behavior:</p>
      <ul>
        <li><strong>CPU Profiling</strong> ‚Äî Records which functions consume the most CPU time, helping identify hot code paths and optimization opportunities</li>
        <li><strong>Heap Snapshots</strong> ‚Äî Captures the state of memory at a point in time, showing all allocated objects and their references</li>
        <li><strong>Heap Timeline</strong> ‚Äî Tracks memory allocation over time to identify leaks and excessive garbage collection</li>
      </ul>

      <h3>Method 1: Command-Line Profiling (--prof)</h3>
      <p>The <code>--prof</code> flag generates a detailed CPU profile that shows time spent in each function.</p>

      <h4>Step 1: Run with Profiling Enabled</h4>
      <pre><code># Start your app with profiling
node --prof app.js

# Reproduce the performance issue, then stop the app (Ctrl+C)
# This creates an isolate-*.log file in the current directory</code></pre>

      <h4>Step 2: Process the Profile</h4>
      <pre><code># Convert the V8 log to human-readable format
node --prof-process isolate-0x*.log > profile.txt</code></pre>

      <h4>Step 3: Read the Results</h4>
      <p>The processed profile shows a breakdown like this:</p>
      <pre><code>[Summary]:
   ticks  total  nonlib   name
   5234   75.2%   78.1%  JavaScript
   1023   14.7%   15.3%  C++
    445    6.4%    6.6%  GC
    258    3.7%          Shared libraries

[JavaScript]:
   ticks  total  nonlib   name
   3102   44.6%   46.3%  pbkdf2Sync
    892   12.8%   13.3%  JSON.parse
    ...</code></pre>
      <p>Look for functions with high tick counts‚Äîthese are your CPU hotspots.</p>

      <h3>Method 2: Chrome DevTools (--inspect)</h3>
      <p>For interactive profiling with a visual interface, use the Chrome DevTools inspector.</p>

      <h4>Step 1: Start with Inspector</h4>
      <pre><code># Local development
node --inspect app.js

# Allow remote connections (e.g., from Azure)
node --inspect=0.0.0.0:9229 app.js</code></pre>

      <h4>Step 2: Connect Chrome DevTools</h4>
      <ol>
        <li>Open Chrome and navigate to <code>chrome://inspect</code></li>
        <li>Click "Configure..." and add <code>localhost:9229</code> (or your remote host)</li>
        <li>Your Node.js process appears under "Remote Target"‚Äîclick "inspect"</li>
      </ol>

      <h4>Step 3: Capture a CPU Profile</h4>
      <ol>
        <li>Go to the <strong>Profiler</strong> tab (or Performance tab)</li>
        <li>Click <strong>Start</strong></li>
        <li>Reproduce the performance issue</li>
        <li>Click <strong>Stop</strong></li>
        <li>Analyze the flame chart‚Äîwide bars indicate slow functions</li>
      </ol>

      <h4>Step 4: Take a Heap Snapshot</h4>
      <ol>
        <li>Go to the <strong>Memory</strong> tab</li>
        <li>Select "Heap snapshot" and click <strong>Take snapshot</strong></li>
        <li>Explore the "Summary" view to see object counts and sizes</li>
        <li>Compare multiple snapshots to identify memory leaks</li>
      </ol>

      <h3>Method 3: Programmatic Heap Snapshots</h3>
      <p>Generate heap snapshots from within your code or via signals:</p>
      <pre><code>// In your application code
const v8 = require('v8');
const fs = require('fs');

function takeHeapSnapshot() {
  const filename = `heap-${Date.now()}.heapsnapshot`;
  const stream = fs.createWriteStream(filename);
  v8.writeHeapSnapshot(filename);
  console.log(`Heap snapshot written to ${filename}`);
}

// Trigger on SIGUSR2 signal
process.on('SIGUSR2', takeHeapSnapshot);</code></pre>
      <p>Then trigger with: <code>kill -USR2 &lt;pid&gt;</code></p>

      <h3>Reading Heap Snapshots</h3>
      <p>Open <code>.heapsnapshot</code> files in Chrome DevTools:</p>
      <ol>
        <li>Open Chrome DevTools (F12)</li>
        <li>Go to <strong>Memory</strong> tab</li>
        <li>Click <strong>Load</strong> and select your <code>.heapsnapshot</code> file</li>
      </ol>
      <p>Key views to analyze:</p>
      <ul>
        <li><strong>Summary</strong> ‚Äî Objects grouped by constructor name. Look for unexpectedly large counts.</li>
        <li><strong>Comparison</strong> ‚Äî Diff two snapshots to see what was allocated between them.</li>
        <li><strong>Containment</strong> ‚Äî Shows the object hierarchy (what's holding references to what).</li>
        <li><strong>Retainers</strong> ‚Äî For any object, shows WHY it's still in memory (the reference chain to GC roots).</li>
      </ul>

      <h3>Azure-Specific Considerations</h3>
      <ul>
        <li><strong>Kudu SSH</strong> ‚Äî Run profiling commands directly via <code>yourapp.scm.azurewebsites.net</code></li>
        <li><strong>Port Forwarding</strong> ‚Äî For remote <code>--inspect</code>, you'll need to configure port forwarding through Azure CLI or VS Code</li>
        <li><strong>File Download</strong> ‚Äî Use Kudu's file browser or <code>az webapp log download</code> to retrieve profile files</li>
        <li><strong>Production Impact</strong> ‚Äî Profiling adds overhead; use on staging or capture briefly in production</li>
      </ul>

      <div class="alert-box info">
        <strong>üí° Quick Reference</strong>
        <ul style="margin: 0.5rem 0 0; padding-left: 1.25rem;">
          <li><strong>CPU slow?</strong> ‚Üí Use <code>--prof</code> or Profiler tab to find hot functions</li>
          <li><strong>Memory growing?</strong> ‚Üí Take heap snapshots and compare over time</li>
          <li><strong>Event loop blocked?</strong> ‚Üí CPU profile during the block shows what's running</li>
        </ul>
      </div>
    </section>

    <!-- Application Insights -->
    <section id="app-insights" class="card">
      <h2>üìä Application Insights Queries</h2>
      <p>Useful KQL queries for diagnosing Node.js issues:</p>

      <h3>Slow Requests</h3>
      <pre><code>requests
| where timestamp > ago(1h)
| where duration > 5000
| summarize count() by bin(timestamp, 5m), name
| render timechart</code></pre>

      <h3>Failed Requests</h3>
      <pre><code>requests
| where timestamp > ago(1h)
| where success == false
| summarize count() by resultCode, name
| order by count_ desc</code></pre>

      <h3>Exception Breakdown</h3>
      <pre><code>exceptions
| where timestamp > ago(24h)
| summarize count() by type, outerMessage
| order by count_ desc</code></pre>

      <h3>Dependency Latency</h3>
      <pre><code>dependencies
| where timestamp > ago(1h)
| summarize avg(duration), percentile(duration, 95) by name
| order by avg_duration desc</code></pre>

      <h3>Custom Event Loop Metric (if instrumented)</h3>
      <pre><code>customMetrics
| where name == "EventLoopLag"
| summarize avg(value), max(value) by bin(timestamp, 1m)
| render timechart</code></pre>
    </section>

  </main>

  <footer>
    <p>Performance Problem Simulator - Educational Tool for Azure App Service Diagnostics</p>
    <p>Created by <a href="https://speckit.org/" target="_blank">SpecKit</a> in collaboration with <a href="mailto:rhamlett@microsoft.com">Richard Hamlett</a></p>
    <p id="build-info">Build: Loading...</p>
  </footer>
  <script>
    // Load environment info for SKU badge
    fetch('/api/health/environment')
      .then(r => r.json())
      .then(env => {
        const badge = document.getElementById('sku-badge');
        if (badge) badge.textContent = 'SKU: ' + env.sku;
      })
      .catch(() => {});
    
    // Load build info for footer
    fetch('/api/health/build')
      .then(r => r.json())
      .then(build => {
        const buildInfo = document.getElementById('build-info');
        if (buildInfo) buildInfo.textContent = 'Build: ' + build.buildTime;
      })
      .catch(() => {});

    // Sidebar drawer toggle
    const hamburgerBtn = document.getElementById('hamburger-btn');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const sidebarDrawer = document.getElementById('sidebar-drawer');
    const sidebarClose = document.getElementById('sidebar-close');

    function openSidebar() {
      hamburgerBtn.classList.remove('attention');
      hamburgerBtn.classList.add('active');
      sidebarOverlay.classList.add('active');
      sidebarDrawer.classList.add('active');
    }

    function closeSidebar() {
      hamburgerBtn.classList.remove('active');
      sidebarOverlay.classList.remove('active');
      sidebarDrawer.classList.remove('active');
    }

    hamburgerBtn.addEventListener('click', openSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);
    sidebarClose.addEventListener('click', closeSidebar);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSidebar();
    });
  </script>
</body>
</html>
