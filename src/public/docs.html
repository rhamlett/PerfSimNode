<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PerfSimNode - Documentation</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    .docs-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 1rem;
      flex: 1;
      min-width: 0;
    }
    .docs-section {
      background-color: var(--color-card);
      border-radius: var(--radius-md);
      padding: 2rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-sm);
    }
    .docs-section h2 {
      color: var(--color-primary);
      border-bottom: 2px solid #edebe9;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }
    .docs-section h3 {
      color: var(--color-text);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .docs-section code {
      background-color: var(--color-bg);
      padding: 0.2rem 0.4rem;
      border-radius: var(--radius-sm);
      font-family: 'Cascadia Code', 'Consolas', monospace;
    }
    .docs-section pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1rem;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      margin: 1rem 0;
    }
    .docs-section pre code {
      background: none;
      padding: 0;
    }
    .warning-box {
      background-color: #fff4ce;
      border-left: 4px solid var(--color-warning);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    .info-box {
      background-color: #e6f3ff;
      border-left: 4px solid var(--color-primary);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #edebe9;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background-color: var(--color-bg);
    }
  </style>
</head>
<body>
  <header>
    <button id="hamburger-btn" class="hamburger-btn attention" aria-label="Open navigation menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <h1>üî• Performance Problem Simulator - Node 24 on Linux</h1>
    <span id="sku-badge" class="sku-badge">SKU: Local</span>
    <nav>
      <a href="/" class="btn-panel-toggle">üéÆ Dashboard</a>
    </nav>
  </header>

  <!-- Sidebar Drawer Navigation -->
  <div id="sidebar-overlay" class="sidebar-overlay"></div>
  <aside id="sidebar-drawer" class="sidebar-drawer">
    <div class="sidebar-header">
      <h2>üî• PerfSimNode</h2>
      <button id="sidebar-close" class="sidebar-close" aria-label="Close navigation">&times;</button>
    </div>
    <nav class="sidebar-nav">
      <div class="sidebar-section-label">Application</div>
      <a href="/" class="sidebar-nav-item">
        <span class="nav-icon">üéÆ</span>
        <span class="nav-label">Dashboard<span class="nav-desc">Live metrics & controls</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">Documentation</div>
      <a href="/docs.html" class="sidebar-nav-item active">
        <span class="nav-icon">üìö</span>
        <span class="nav-label">Documentation<span class="nav-desc">API reference & guides</span></span>
      </a>
      <a href="/azure-diagnostics.html" class="sidebar-nav-item">
        <span class="nav-icon">‚òÅÔ∏è</span>
        <span class="nav-label">Azure Diagnostics<span class="nav-desc">Diagnose issues in App Service</span></span>
      </a>
      <a href="/azure-deployment.html" class="sidebar-nav-item">
        <span class="nav-icon">üöÄ</span>
        <span class="nav-label">Deploy to Azure<span class="nav-desc">GitHub Actions + OIDC setup</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">External</div>
      <a href="https://github.com/rhamlett/PerfSimNode" target="_blank" class="sidebar-nav-item">
        <span class="nav-icon">üêô</span>
        <span class="nav-label">GitHub Repository<span class="nav-desc">Source code & issues</span></span>
      </a>
    </nav>
    <div class="sidebar-footer">
      PerfSimNode v1.0 ‚Ä¢ Node.js 24 LTS
    </div>
  </aside>

  <div class="docs-page-wrapper">
  <main class="docs-container">

    <section id="overview" class="docs-section">
      <h2>Overview</h2>
      <p>PerfSimNode is an educational tool designed to help Azure support engineers practice diagnosing common Node.js performance problems. It intentionally generates controllable performance issues that mimic real-world scenarios.</p>
      
      <h3>Features</h3>
      <ul>
        <li><strong>CPU Stress</strong> - Generate high CPU usage at configurable percentages</li>
        <li><strong>Memory Pressure</strong> - Allocate and retain memory to simulate leaks</li>
        <li><strong>Event Loop Blocking</strong> - Block the Node.js event loop with synchronous operations</li>
        <li><strong>Slow Requests</strong> - Simulate slow HTTP responses</li>
        <li><strong>Crash Simulation</strong> - Trigger unhandled exceptions or OOM conditions</li>
      </ul>

      <h3>Architecture</h3>
      <p>The application runs as a single Node.js process with Express.js, Socket.IO for real-time metrics, and in-memory state.</p>
      <pre><code>src/
‚îú‚îÄ‚îÄ controllers/                # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ admin.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ cpu.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ crash.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ eventloop.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ health.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ memory.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ metrics.controller.ts
‚îÇ   ‚îî‚îÄ‚îÄ slow.controller.ts
‚îÇ
‚îú‚îÄ‚îÄ services/                   # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ cpu-stress.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ crash.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ event-log.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ eventloop-block.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ memory-pressure.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ metrics.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ simulation-tracker.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ slow-request.service.ts
‚îÇ
‚îú‚îÄ‚îÄ middleware/                 # Express middleware
‚îú‚îÄ‚îÄ types/                      # TypeScript interfaces
‚îú‚îÄ‚îÄ config/                     # Configuration
‚îÇ
‚îî‚îÄ‚îÄ public/                     # Static dashboard
    ‚îú‚îÄ‚îÄ index.html              # Main dashboard
    ‚îú‚îÄ‚îÄ docs.html               # Documentation
    ‚îú‚îÄ‚îÄ azure-diagnostics.html  # Diagnostics guide
    ‚îî‚îÄ‚îÄ js/
        ‚îú‚îÄ‚îÄ charts.js           # Real-time charts
        ‚îú‚îÄ‚îÄ dashboard.js        # UI interactions
        ‚îî‚îÄ‚îÄ socket-client.js    # WebSocket client</code></pre>
    </section>

    <section id="cpu-stress" class="docs-section">
      <h2>CPU Stress Simulation</h2>
      <p>Generates high CPU usage using separate OS processes via <code>child_process.fork()</code>.</p>

      <h3>How It Works</h3>
      <p>Unlike naive CPU burning in the main thread (which would block Node.js), this simulation spawns separate child processes that each run <code>crypto.pbkdf2Sync()</code> in a tight loop. The OS scheduler distributes these processes across CPU cores.</p>
      
      <div class="info-box">
        <strong>üí° Node.js Insight:</strong> CPU-intensive work must be isolated from the main event loop. Child processes guarantee true multi-core utilization without blocking request handling.
      </div>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/cpu
Content-Type: application/json

{
  "targetLoadPercent": 75,
  "durationSeconds": 30
}</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>targetLoadPercent</td><td>1-100</td><td>Target CPU usage percentage (spawns proportional workers)</td></tr>
        <tr><td>durationSeconds</td><td>1-300</td><td>How long to run the simulation</td></tr>
      </table>

      <h3>Expected Effects</h3>
      <ul>
        <li>CPU tile/chart increases to target percentage</li>
        <li>Event loop lag stays LOW (work is in child processes)</li>
        <li>Request latency may increase slightly due to CPU contention</li>
        <li>Multiple <code>node</code> processes visible in <code>top</code>/<code>htop</code></li>
      </ul>

      <div class="info-box">
        <strong>üìä About CPU Metrics:</strong> The dashboard samples CPU at 250ms intervals using raw <code>os.cpus()</code> data. This high-resolution approach may show significant fluctuations even at idle due to GC, curl probes, and container scheduling. Focus on the <em>trend</em> during simulations, not individual spikes. Production tools (Azure Monitor) sample every 1 minute with averaging.
      </div>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>top</code> / <code>htop</code> - View all node processes</li>
        <li><code>ps aux | grep node</code> - See child process tree</li>
        <li>Azure App Service Diagnostics ‚Üí CPU drill-down</li>
        <li>Application Insights ‚Üí Performance metrics</li>
      </ul>
    </section>

    <section id="memory-pressure" class="docs-section">
      <h2>Memory Pressure Simulation</h2>
      <p>Allocates and retains memory buffers filled with random data to simulate memory leaks.</p>

      <h3>How It Works</h3>
      <p>Uses <code>Buffer.alloc()</code> to allocate memory that is held until explicitly released. Buffers are filled with random data to prevent V8 optimization. Multiple allocations can coexist (stacking behavior).</p>

      <div class="info-box">
        <strong>üí° Node.js Insight:</strong> V8's garbage collector uses generational collection. Large allocations may cause longer GC pauses, visible as event loop lag spikes.
      </div>

      <h3>Usage</h3>
      <pre><code># Allocate memory
POST /api/simulations/memory
{"sizeMb": 100}

# Release memory (use the returned ID)
DELETE /api/simulations/memory/{id}</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>sizeMb</td><td>1-500</td><td>Memory to allocate in megabytes</td></tr>
      </table>

      <h3>Expected Effects</h3>
      <ul>
        <li>Heap memory increases by allocation size</li>
        <li>RSS memory increases proportionally</li>
        <li>Brief event loop lag spikes during allocation (GC)</li>
        <li>Saw-tooth pattern as GC runs between allocations</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>node --inspect</code> - Take heap snapshots via Chrome DevTools</li>
        <li>Azure App Service ‚Üí Memory metrics</li>
        <li>Application Insights ‚Üí customMetrics for heap stats</li>
        <li><code>process.memoryUsage()</code> - Programmatic access</li>
      </ul>
    </section>

    <section id="eventloop-blocking" class="docs-section">
      <h2>Event Loop Blocking Simulation</h2>
      <p>Demonstrates how synchronous operations block the Node.js event loop, making the server completely unresponsive.</p>

      <div class="warning-box">
        <strong>‚ö†Ô∏è Warning:</strong> During this simulation, the server will be completely unresponsive to all requests. WebSocket connections may timeout. The dashboard will freeze.
      </div>

      <h3>How It Works</h3>
      <p>Performs synchronous <code>crypto.pbkdf2Sync()</code> directly in the main thread. All pending I/O, timers, and incoming requests are queued until the blocking completes.</p>

      <div class="info-box">
        <strong>üí° Key Difference from CPU Stress:</strong> CPU stress uses child processes (server stays responsive). Event loop blocking runs in the main thread (server becomes unresponsive). Check the Event Loop Lag metric to distinguish them!
      </div>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/eventloop
{"durationSeconds": 5}</code></pre>

      <h3>Symptoms to Observe</h3>
      <ul>
        <li>Event loop lag spikes to equal the blocking duration</li>
        <li>All requests queue and complete together after unblock</li>
        <li>WebSocket heartbeats fail (dashboard freezes)</li>
        <li>Probe dots turn red during the block</li>
        <li>Health checks fail/timeout</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>perf_hooks.monitorEventLoopDelay()</code> - Built into this app's metrics</li>
        <li>Clinic.js Doctor - Analyze event loop issues</li>
        <li>0x - Flame graph profiling for synchronous hotspots</li>
      </ul>
    </section>

    <section id="slow-requests" class="docs-section">
      <h2>Slow Request Simulation</h2>
      <p>Simulates slow HTTP responses using multiple blocking patterns to observe different resource contention behaviors.</p>

      <h3>Blocking Patterns</h3>
      <table>
        <tr><th>Pattern</th><th>Description</th><th>Affected Resources</th></tr>
        <tr><td><code>setTimeout</code></td><td>Non-blocking delay (default)</td><td>None - server stays responsive</td></tr>
        <tr><td><code>libuv</code></td><td>Saturates libuv thread pool</td><td>fs, dns, crypto operations queue up</td></tr>
        <tr><td><code>worker</code></td><td>Spawns blocking worker threads</td><td>CPU, similar to .NET ThreadPool</td></tr>
      </table>

      <div class="info-box">
        <strong>üí° .NET Parallel:</strong> The <code>libuv</code> and <code>worker</code> patterns simulate thread pool starvation similar to sync-over-async blocking patterns in .NET that exhaust ThreadPool threads.
      </div>

      <h3>Usage</h3>
      <pre><code># Non-blocking (default)
GET /api/simulations/slow?delaySeconds=10

# libuv thread pool saturation
GET /api/simulations/slow?delaySeconds=10&blockingPattern=libuv

# Worker thread blocking
GET /api/simulations/slow?delaySeconds=10&blockingPattern=worker</code></pre>

      <h3>Expected Effects by Pattern</h3>
      <h4>setTimeout (Non-Blocking)</h4>
      <ul>
        <li>Slow endpoint takes configured delay time</li>
        <li>Probe latency remains normal</li>
        <li>Event loop lag stays near zero</li>
      </ul>

      <h4>libuv Thread Pool Saturation</h4>
      <ul>
        <li>File system operations slow down</li>
        <li>DNS lookups become slow</li>
        <li>HTTP requests still process normally</li>
      </ul>

      <h4>Worker Thread Blocking</h4>
      <ul>
        <li>CPU usage increases</li>
        <li>Thread count increases</li>
        <li>Main event loop unaffected</li>
      </ul>

      <h3>Dashboard Controls</h3>
      <ul>
        <li><strong>Blocking Pattern:</strong> setTimeout, libuv, or worker</li>
        <li><strong>Delay:</strong> How long each request takes (1-300 seconds)</li>
        <li><strong>Interval:</strong> Time between automated requests</li>
        <li><strong>Max Requests:</strong> How many to send before stopping</li>
      </ul>

      <h3>Use Cases</h3>
      <ul>
        <li>Testing timeout configurations</li>
        <li>Simulating thread pool starvation</li>
        <li>Understanding blocking vs non-blocking behavior</li>
        <li>Comparing Node.js concurrency model to .NET</li>
      </ul>
    </section>

    <section id="crash-simulation" class="docs-section">
      <h2>Crash Simulation</h2>
      <p>Intentionally crashes the Node.js process for testing crash recovery and observing restart behavior.</p>

      <div class="warning-box">
        <strong>‚ö†Ô∏è Warning:</strong> These operations will terminate the process. In Azure App Service, the process will restart automatically. Dashboard will disconnect and reconnect.
      </div>

      <h3>Crash Types</h3>
      <table>
        <tr><th>Type</th><th>Endpoint</th><th>Method</th><th>Effect</th></tr>
        <tr><td>FailFast</td><td><code>/crash/failfast</code></td><td><code>process.abort()</code></td><td>Immediate SIGABRT, core dump</td></tr>
        <tr><td>Stack Overflow</td><td><code>/crash/stackoverflow</code></td><td>Infinite recursion</td><td>RangeError, call stack exceeded</td></tr>
        <tr><td>Exception</td><td><code>/crash/exception</code></td><td><code>throw Error</code></td><td>Unhandled exception terminates</td></tr>
        <tr><td>OOM</td><td><code>/crash/memory</code></td><td>Infinite allocation</td><td>Heap exhaustion, OOM kill</td></tr>
      </table>

      <h3>Expected Behavior</h3>
      <ul>
        <li>Process terminates immediately</li>
        <li>Dashboard shows disconnection</li>
        <li>Azure App Service auto-restarts process</li>
        <li>After restart: new Process ID, cleared simulations, fresh metrics</li>
        <li>Event Log shows: "üîÑ APPLICATION RESTARTED! Process ID changed..."</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li>Azure App Service ‚Üí Diagnose and Solve Problems ‚Üí Application Crashes</li>
        <li>Log Stream (real-time crash logs)</li>
        <li>Kudu ‚Üí LogFiles ‚Üí Application</li>
        <li>Application Insights ‚Üí Failures blade</li>
      </ul>
    </section>

    <section id="diagnostics" class="docs-section">
      <h2>Diagnostics</h2>
      <p>For comprehensive guidance on diagnosing Node.js performance issues, see the dedicated <a href="/azure-diagnostics.html"><strong>Azure Diagnostics Guide</strong></a>.</p>
      
      <h3>What's Covered</h3>
      <ul>
        <li><strong>Understanding Metrics</strong> - What CPU, memory, event loop lag, and latency metrics mean</li>
        <li><strong>Node.js vs .NET</strong> - Key differences in concurrency models and diagnostic approaches</li>
        <li><strong>Diagnostic Scenarios</strong> - Step-by-step walkthroughs for each simulation type</li>
        <li><strong>Azure Tools</strong> - App Service Diagnostics, Application Insights, Kudu console</li>
        <li><strong>Linux Tools</strong> - Process monitoring, Node.js debugging, network analysis</li>
        <li><strong>AppLens Queries</strong> - Ready-to-use KQL queries for Azure diagnostics</li>
      </ul>
      
      <div class="info-box">
        <strong>üí° Tip:</strong> Open the <a href="/azure-diagnostics.html">Azure Diagnostics Guide</a> in a separate tab while running simulations to follow along with the diagnostic workflows.
      </div>
    </section>

    <section id="api-reference" class="docs-section">
      <h2>API Reference</h2>
      
      <h3>Health & Metrics</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/health</code></td><td>GET</td><td>Health check with uptime</td></tr>
        <tr><td><code>/api/metrics/probe</code></td><td>GET</td><td>Lightweight probe for latency monitoring</td></tr>
        <tr><td><code>/api/metrics</code></td><td>GET</td><td>Current system metrics (CPU, memory, event loop)</td></tr>
      </table>
      
      <h3>Simulations</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/simulations</code></td><td>GET</td><td>List all active simulations</td></tr>
        <tr><td><code>/api/simulations/cpu</code></td><td>POST</td><td>Start CPU stress (child processes)</td></tr>
        <tr><td><code>/api/simulations/cpu/:id</code></td><td>DELETE</td><td>Stop CPU stress</td></tr>
        <tr><td><code>/api/simulations/memory</code></td><td>POST</td><td>Allocate memory</td></tr>
        <tr><td><code>/api/simulations/memory/:id</code></td><td>DELETE</td><td>Release memory</td></tr>
        <tr><td><code>/api/simulations/eventloop</code></td><td>POST</td><td>Block event loop</td></tr>
        <tr><td><code>/api/simulations/slow</code></td><td>GET</td><td>Slow request with delay</td></tr>
      </table>
      
      <h3>Crash Endpoints</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Crash Type</th></tr>
        <tr><td><code>/api/simulations/crash/failfast</code></td><td>POST</td><td>FailFast (SIGABRT)</td></tr>
        <tr><td><code>/api/simulations/crash/stackoverflow</code></td><td>POST</td><td>Stack overflow</td></tr>
        <tr><td><code>/api/simulations/crash/exception</code></td><td>POST</td><td>Unhandled exception</td></tr>
        <tr><td><code>/api/simulations/crash/memory</code></td><td>POST</td><td>Memory exhaustion</td></tr>
      </table>
      
      <h3>Admin</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/admin/status</code></td><td>GET</td><td>Admin status with configuration</td></tr>
        <tr><td><code>/api/admin/events</code></td><td>GET</td><td>Event log (limit via ?limit=N)</td></tr>
        <tr><td><code>/api/admin/system-info</code></td><td>GET</td><td>System info (CPUs, memory, SKU)</td></tr>
      </table>

      <h3>WebSocket Events (Socket.IO)</h3>
      <p>Connect via Socket.IO to receive real-time updates:</p>
      <table>
        <tr><th>Event</th><th>Frequency</th><th>Description</th></tr>
        <tr><td><code>metrics</code></td><td>1000ms</td><td>System metrics (CPU, memory, event loop)</td></tr>
        <tr><td><code>probeLatency</code></td><td>250ms / 2500ms</td><td>Request latency measurements</td></tr>
        <tr><td><code>event</code></td><td>On occurrence</td><td>Simulation and system events</td></tr>
        <tr><td><code>simulation</code></td><td>On status change</td><td>Simulation state updates</td></tr>
      </table>
      <p><em>Probe frequency automatically increases to 2500ms during slow request testing for cleaner diagnostics.</em></p>
    </section>

    <section id="load-testing" class="docs-section">
      <h2>Azure Load Testing</h2>
      <p>The Performance Problem Simulator includes a dedicated load testing endpoint designed for use with Azure Load Testing. This endpoint simulates realistic application behavior that degrades gracefully under load.</p>

      <h3>Load Test Endpoint</h3>
      <p>Unlike other simulation endpoints, this one does NOT appear in the dashboard UI and is meant for automated load testing scenarios only.</p>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/loadtest</code></td><td>GET</td><td>Execute load test with query parameters</td></tr>
        <tr><td><code>/api/loadtest/stats</code></td><td>GET</td><td>Get current concurrent request statistics</td></tr>
      </table>

      <h3>Usage</h3>
      <p>Use the <code>GET /api/loadtest</code> endpoint directly in Azure Load Testing &mdash; no JMeter script required:</p>
      <pre><code># With defaults
https://your-app.azurewebsites.net/api/loadtest

# Custom parameters
https://your-app.azurewebsites.net/api/loadtest?workIterations=500&amp;bufferSizeKb=10000

# Thread pool only (no CPU work)
https://your-app.azurewebsites.net/api/loadtest?workIterations=0&amp;bufferSizeKb=100</code></pre>

      <h3>Query Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
        <tr><td><code>workIterations</code></td><td>200</td><td>CPU spin iterations per work cycle (ms per cycle = workIterations/100)</td></tr>
        <tr><td><code>bufferSizeKb</code></td><td>20000</td><td>Memory buffer held for entire request duration (KB)</td></tr>
        <tr><td><code>baselineDelayMs</code></td><td>500</td><td>Minimum request duration (ms)</td></tr>
        <tr><td><code>softLimit</code></td><td>25</td><td>Concurrent requests before degradation begins</td></tr>
        <tr><td><code>degradationFactor</code></td><td>500</td><td>Delay ms added per request over soft limit</td></tr>
      </table>

      <h3>Behavior (Sustained Resource Consumption)</h3>
      <ul>
        <li><strong>Memory:</strong> Allocated up front and held for entire request duration (visible in Azure Memory metrics)</li>
        <li><strong>CPU:</strong> Interleaved work cycles (spin loop + sleep) creating sustained CPU usage per active request</li>
        <li><strong>Degradation:</strong> Blocking delay = baselineDelayMs + max(0, concurrent - softLimit) &times; degradationFactor</li>
        <li><strong>After 120 seconds:</strong> 20% chance of throwing a random exception per check interval</li>
        <li><strong>Extreme load:</strong> Can reach Azure's 230-second timeout threshold</li>
      </ul>

      <h3>What It Tests</h3>
      <ul>
        <li><strong>CPU</strong> &mdash; Sustained spin loop cycles per active thread</li>
        <li><strong>Memory</strong> &mdash; Buffers held for entire request duration</li>
        <li><strong>Event Loop</strong> &mdash; Graceful degradation under concurrent load</li>
        <li><strong>Timeouts</strong> &mdash; Random exceptions after 120s (20% probability)</li>
      </ul>

      <div class="info-box">
        <strong>&#x1f4d8; Full Documentation:</strong> See the <a href="/azure-diagnostics.html#load-testing">Azure Diagnostics Guide</a> for detailed setup instructions, tuning scenarios, and diagnostic techniques.
      </div>
    </section>
  </main>

  <!-- Right Sidebar: On This Page -->
  <aside class="docs-right-sidebar">
    <div class="sidebar-card">
      <div class="sidebar-title">ON THIS PAGE</div>
      <ul class="sidebar-links" id="page-nav">
        <li><a href="#overview">üéØ Overview</a></li>
      </ul>
      <div class="sidebar-section-label">SIMULATIONS</div>
      <ul class="sidebar-links" id="page-nav-sims">
        <li><a href="#cpu-stress">üî• CPU Stress</a></li>
        <li><a href="#memory-pressure">üìä Memory Pressure</a></li>
        <li><a href="#eventloop-blocking">üü£ Event Loop Blocking</a></li>
        <li><a href="#slow-requests">üê¢ Slow Requests</a></li>
        <li><a href="#crash-simulation">üí• Crash Simulation</a></li>
      </ul>
      <div class="sidebar-section-label">REFERENCE</div>
      <ul class="sidebar-links" id="page-nav-ref">
        <li><a href="#diagnostics">üî¨ Diagnostics</a></li>
        <li><a href="#api-reference">üìã API Reference</a></li>
        <li><a href="#load-testing">üìà Azure Load Testing</a></li>
      </ul>
    </div>
  </aside>
  </div><!-- /docs-page-wrapper -->

  <footer>
    <p>Performance Problem Simulator - Educational Tool for Azure App Service Diagnostics</p>
    <p>Created by <a href="https://speckit.org/" target="_blank">SpecKit</a> in collaboration with <a href="mailto:rhamlett@microsoft.com">Richard Hamlett</a></p>
    <p id="build-info">Build: Loading...</p>
  </footer>
  <script>
    // Load environment info for SKU badge
    fetch('/api/health/environment')
      .then(r => r.json())
      .then(env => {
        const badge = document.getElementById('sku-badge');
        if (badge) badge.textContent = 'SKU: ' + env.sku;
      })
      .catch(() => {});
    
    // Load build info for footer
    fetch('/api/health/build')
      .then(r => r.json())
      .then(build => {
        const buildInfo = document.getElementById('build-info');
        if (buildInfo) buildInfo.textContent = 'Build: ' + build.buildTime;
      })
      .catch(() => {});

    // Sidebar drawer toggle
    const hamburgerBtn = document.getElementById('hamburger-btn');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const sidebarDrawer = document.getElementById('sidebar-drawer');
    const sidebarClose = document.getElementById('sidebar-close');

    function openSidebar() {
      hamburgerBtn.classList.remove('attention');
      hamburgerBtn.classList.add('active');
      sidebarOverlay.classList.add('active');
      sidebarDrawer.classList.add('active');
    }

    function closeSidebar() {
      hamburgerBtn.classList.remove('active');
      sidebarOverlay.classList.remove('active');
      sidebarDrawer.classList.remove('active');
    }

    hamburgerBtn.addEventListener('click', openSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);
    sidebarClose.addEventListener('click', closeSidebar);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSidebar();
    });

    // Scroll-spy: highlight active section in right sidebar
    (function() {
      const links = document.querySelectorAll('#page-nav a, #page-nav-sims a, #page-nav-ref a');
      const sections = [];
      links.forEach(link => {
        const id = link.getAttribute('href').slice(1);
        const el = document.getElementById(id);
        if (el) sections.push({ id, el, link });
      });
      function updateActive() {
        let current = sections[0];
        for (const s of sections) {
          if (s.el.getBoundingClientRect().top <= 100) current = s;
        }
        links.forEach(l => l.classList.remove('active'));
        if (current) current.link.classList.add('active');
      }
      window.addEventListener('scroll', updateActive, { passive: true });
      updateActive();
    })();
  </script>
</body>
</html>
