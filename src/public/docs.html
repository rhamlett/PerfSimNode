<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PerfSimNode - Documentation</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    .docs-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 1rem;
    }
    .docs-nav {
      background-color: var(--color-card);
      border-radius: var(--radius-md);
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow-sm);
    }
    .docs-nav ul {
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .docs-nav a {
      display: inline-block;
      padding: 0.5rem 1rem;
      background-color: var(--color-bg);
      border-radius: var(--radius-sm);
      text-decoration: none;
      color: var(--color-text);
    }
    .docs-nav a:hover {
      background-color: var(--color-primary);
      color: white;
    }
    .docs-section {
      background-color: var(--color-card);
      border-radius: var(--radius-md);
      padding: 2rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-sm);
    }
    .docs-section h2 {
      color: var(--color-primary);
      border-bottom: 2px solid #edebe9;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }
    .docs-section h3 {
      color: var(--color-text);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .docs-section code {
      background-color: var(--color-bg);
      padding: 0.2rem 0.4rem;
      border-radius: var(--radius-sm);
      font-family: 'Cascadia Code', 'Consolas', monospace;
    }
    .docs-section pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1rem;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      margin: 1rem 0;
    }
    .docs-section pre code {
      background: none;
      padding: 0;
    }
    .warning-box {
      background-color: #fff4ce;
      border-left: 4px solid var(--color-warning);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    .info-box {
      background-color: #e6f3ff;
      border-left: 4px solid var(--color-primary);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #edebe9;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background-color: var(--color-bg);
    }
  </style>
</head>
<body>
  <header>
    <h1>üî• Performance Problem Simulator - Node 24 on Linux</h1>
    <span id="sku-badge" class="sku-badge">SKU: Local</span>
    <nav>
      <a href="https://github.com/rhamlett/PerfSimNode" target="_blank" class="nav-link">üêô GitHub</a>
      <a href="/azure-diagnostics.html" class="nav-link">‚òÅÔ∏è Azure Diagnostics</a>
      <a href="/docs.html" class="nav-link active">üìö Documentation</a>
      <a href="/" class="btn-panel-toggle">üéÆ Dashboard</a>
    </nav>
  </header>

  <main class="docs-container">
    <nav class="docs-nav">
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#cpu-stress">CPU Stress</a></li>
        <li><a href="#memory-pressure">Memory Pressure</a></li>
        <li><a href="#eventloop-blocking">Event Loop Blocking</a></li>
        <li><a href="#slow-requests">Slow Requests</a></li>
        <li><a href="#crash-simulation">Crash Simulation</a></li>
        <li><a href="#diagnostics">Diagnostics</a></li>
        <li><a href="#api-reference">API Reference</a></li>
      </ul>
    </nav>

    <section id="overview" class="docs-section">
      <h2>Overview</h2>
      <p>PerfSimNode is an educational tool designed to help Azure support engineers practice diagnosing common Node.js performance problems. It intentionally generates controllable performance issues that mimic real-world scenarios.</p>
      
      <h3>Features</h3>
      <ul>
        <li><strong>CPU Stress</strong> - Generate high CPU usage at configurable percentages</li>
        <li><strong>Memory Pressure</strong> - Allocate and retain memory to simulate leaks</li>
        <li><strong>Event Loop Blocking</strong> - Block the Node.js event loop with synchronous operations</li>
        <li><strong>Slow Requests</strong> - Simulate slow HTTP responses</li>
        <li><strong>Crash Simulation</strong> - Trigger unhandled exceptions or OOM conditions</li>
      </ul>

      <h3>Architecture</h3>
      <p>The application runs as a single Node.js process with Express.js, Socket.IO for real-time metrics, and in-memory state.</p>
      <pre><code>src/
‚îú‚îÄ‚îÄ controllers/                # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ admin.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ cpu.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ crash.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ eventloop.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ health.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ memory.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ metrics.controller.ts
‚îÇ   ‚îî‚îÄ‚îÄ slow.controller.ts
‚îÇ
‚îú‚îÄ‚îÄ services/                   # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ cpu-stress.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ crash.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ event-log.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ eventloop-block.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ memory-pressure.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ metrics.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ simulation-tracker.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ slow-request.service.ts
‚îÇ
‚îú‚îÄ‚îÄ middleware/                 # Express middleware
‚îú‚îÄ‚îÄ types/                      # TypeScript interfaces
‚îú‚îÄ‚îÄ config/                     # Configuration
‚îÇ
‚îî‚îÄ‚îÄ public/                     # Static dashboard
    ‚îú‚îÄ‚îÄ index.html              # Main dashboard
    ‚îú‚îÄ‚îÄ docs.html               # Documentation
    ‚îú‚îÄ‚îÄ azure-diagnostics.html  # Diagnostics guide
    ‚îî‚îÄ‚îÄ js/
        ‚îú‚îÄ‚îÄ charts.js           # Real-time charts
        ‚îú‚îÄ‚îÄ dashboard.js        # UI interactions
        ‚îî‚îÄ‚îÄ socket-client.js    # WebSocket client</code></pre>
    </section>

    <section id="cpu-stress" class="docs-section">
      <h2>CPU Stress Simulation</h2>
      <p>Generates high CPU usage by performing cryptographic operations (PBKDF2) in a controlled loop.</p>

      <h3>How It Works</h3>
      <p>The simulation uses <code>crypto.pbkdf2Sync()</code> to perform CPU-intensive password hashing. The load percentage is achieved by burning CPU for a portion of each 100ms interval.</p>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/cpu
Content-Type: application/json

{
  "targetLoadPercent": 80,
  "durationSeconds": 30
}</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>targetLoadPercent</td><td>1-100</td><td>Target CPU usage percentage</td></tr>
        <tr><td>durationSeconds</td><td>1-300</td><td>How long to run the simulation</td></tr>
      </table>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>top</code> / <code>htop</code> - View CPU usage in real-time</li>
        <li>Azure App Service Diagnostics ‚Üí CPU drill-down</li>
        <li>Application Insights ‚Üí Performance metrics</li>
      </ul>
    </section>

    <section id="memory-pressure" class="docs-section">
      <h2>Memory Pressure Simulation</h2>
      <p>Allocates and retains memory buffers to simulate memory leaks or high memory usage.</p>

      <h3>How It Works</h3>
      <p>Uses <code>Buffer.alloc()</code> to allocate memory that is held until explicitly released. Multiple allocations can coexist (stacking behavior).</p>

      <h3>Usage</h3>
      <pre><code># Allocate memory
POST /api/simulations/memory
{"sizeMb": 100}

# Release memory (use the returned ID)
DELETE /api/simulations/memory/{id}</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>sizeMb</td><td>1-500</td><td>Memory to allocate in megabytes</td></tr>
      </table>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>node --inspect</code> - Take heap snapshots</li>
        <li>Azure App Service ‚Üí Memory metrics</li>
        <li>Application Insights ‚Üí Memory tracking</li>
        <li><code>process.memoryUsage()</code> - Programmatic access</li>
      </ul>
    </section>

    <section id="eventloop-blocking" class="docs-section">
      <h2>Event Loop Blocking Simulation</h2>
      <p>Demonstrates how synchronous operations can block the Node.js event loop, making the server unresponsive.</p>

      <div class="warning-box">
        <strong>Warning:</strong> During this simulation, the server will be completely unresponsive to all requests. WebSocket connections may timeout.
      </div>

      <h3>How It Works</h3>
      <p>Performs synchronous cryptographic operations that block the single-threaded event loop. All pending I/O, timers, and incoming requests are queued until the blocking completes.</p>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/eventloop
{"durationSeconds": 5}</code></pre>

      <h3>Symptoms to Observe</h3>
      <ul>
        <li>Event loop lag spikes in metrics</li>
        <li>Requests timeout or take unexpectedly long</li>
        <li>WebSocket heartbeats fail</li>
        <li>Health checks fail during blocking</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>perf_hooks.monitorEventLoopDelay()</code> - Measure lag</li>
        <li>Clinic.js Doctor - Analyze event loop issues</li>
        <li>0x - Flame graph profiling</li>
      </ul>
    </section>

    <section id="slow-requests" class="docs-section">
      <h2>Slow Request Simulation</h2>
      <p>Simulates slow HTTP responses using artificial delays.</p>

      <h3>How It Works</h3>
      <p>Uses <code>setTimeout()</code> to delay the response for a configurable duration. Unlike event loop blocking, this doesn't affect other requests.</p>

      <h3>Usage</h3>
      <pre><code># Using query parameter (easy browser testing)
GET /api/simulations/slow?delaySeconds=10</code></pre>

      <h3>Use Cases</h3>
      <ul>
        <li>Testing timeout configurations</li>
        <li>Simulating slow external API calls</li>
        <li>Load balancer health check testing</li>
      </ul>
    </section>

    <section id="crash-simulation" class="docs-section">
      <h2>Crash Simulation</h2>
      <p>Intentionally crashes the Node.js process for testing crash recovery.</p>

      <div class="warning-box">
        <strong>Warning:</strong> These operations will terminate the process. In Azure App Service, the process will restart automatically.
      </div>

      <h3>Unhandled Exception</h3>
      <pre><code>POST /api/simulations/crash/exception</code></pre>
      <p>Throws an unhandled exception that terminates the process.</p>

      <h3>Memory Exhaustion (OOM)</h3>
      <pre><code>POST /api/simulations/crash/memory</code></pre>
      <p>Rapidly allocates memory until the process is killed by the OS.</p>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li>Azure App Service ‚Üí Diagnose and Solve Problems</li>
        <li>Application Insights ‚Üí Failures</li>
        <li>Kudu ‚Üí LogFiles</li>
      </ul>
    </section>

    <section id="diagnostics" class="docs-section">
      <h2>Diagnostics</h2>
      <p>For comprehensive guidance on diagnosing Node.js performance issues, see the dedicated <a href="/azure-diagnostics.html"><strong>Azure Diagnostics Guide</strong></a>.</p>
      
      <h3>What's Covered</h3>
      <ul>
        <li><strong>Understanding Metrics</strong> - What CPU, memory, event loop lag, and latency metrics mean</li>
        <li><strong>Node.js vs .NET</strong> - Key differences in concurrency models and diagnostic approaches</li>
        <li><strong>Diagnostic Scenarios</strong> - Step-by-step walkthroughs for each simulation type</li>
        <li><strong>Azure Tools</strong> - App Service Diagnostics, Application Insights, Kudu console</li>
        <li><strong>Linux Tools</strong> - Process monitoring, Node.js debugging, network analysis</li>
        <li><strong>AppLens Queries</strong> - Ready-to-use KQL queries for Azure diagnostics</li>
      </ul>
      
      <div class="info-box">
        <strong>üí° Tip:</strong> Open the <a href="/azure-diagnostics.html">Azure Diagnostics Guide</a> in a separate tab while running simulations to follow along with the diagnostic workflows.
      </div>
    </section>

    <section id="api-reference" class="docs-section">
      <h2>API Reference</h2>
      
      <h3>Health Check</h3>
      <pre><code>GET /api/health</code></pre>
      <p>Returns service status and uptime.</p>

      <h3>Metrics</h3>
      <pre><code>GET /api/metrics</code></pre>
      <p>Returns current system metrics (CPU, memory, event loop lag).</p>

      <h3>List Active Simulations</h3>
      <pre><code>GET /api/simulations</code></pre>
      <p>Returns all currently active simulations.</p>

      <h3>Admin Status</h3>
      <pre><code>GET /api/admin/status</code></pre>
      <p>Returns detailed status including configuration.</p>

      <h3>Event Log</h3>
      <pre><code>GET /api/admin/events?limit=50</code></pre>
      <p>Returns recent event log entries.</p>

      <h3>WebSocket Events</h3>
      <p>Connect via Socket.IO to receive real-time updates:</p>
      <ul>
        <li><code>metrics</code> - System metrics (every second)</li>
        <li><code>event</code> - Simulation events</li>
        <li><code>simulation</code> - Simulation status changes</li>
      </ul>
    </section>
  </main>

  <footer>
    <p>Performance Problem Simulator - Educational Tool for Azure App Service Diagnostics</p>
    <p>Created by <a href="https://speckit.org/" target="_blank">SpecKit</a> in collaboration with <a href="mailto:rhamlett@microsoft.com">Richard Hamlett</a></p>
    <p id="build-info">Build: Loading...</p>
  </footer>
  <script>
    // Load environment info for SKU badge
    fetch('/api/health/environment')
      .then(r => r.json())
      .then(env => {
        const badge = document.getElementById('sku-badge');
        if (badge) badge.textContent = 'SKU: ' + env.sku;
      })
      .catch(() => {});
    
    // Load build info for footer
    fetch('/api/health/build')
      .then(r => r.json())
      .then(build => {
        const buildInfo = document.getElementById('build-info');
        if (buildInfo) buildInfo.textContent = 'Build: ' + build.buildTime;
      })
      .catch(() => {});
  </script>
</body>
</html>
